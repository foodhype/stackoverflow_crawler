<h1>
functional programming - Java 8 flatMap + Optional.of doesn't compile - Stack Overflow
<\h1>
<p>I'm trying to <code>flatMap</code> <code>Optional</code>s in Java. Here is a simplified example:</p>
<pre><code>List&lt;String&gt; x = Arrays.asList("a", "b", "c");
List&lt;String&gt; result = x.stream().flatMap((val) -&gt; val.equals("b") ? Optional.empty() : Optional.of(val)).collect(Collectors.toList());
</code></pre>
<p>I get this error message from the compiler:</p>
<pre><code>Error:(10, 27) java: incompatible types: no instance(s) of type variable(s) T exist so that java.util.Optional&lt;T&gt; conforms to java.util.stream.Stream&lt;? extends R&gt;
</code></pre>
<p>What's wrong? Here is an example of what I'm trying to achieve in Scala:</p>
<pre><code>List("a", "b", "c").flatMap(x =&gt; if (x == "b") None else Some(x))
</code></pre>
<p>It returns:</p>
<pre><code>res2: List[String] = List(a, c)
</code></pre>
<p>as expected. </p>
<p>How do I convert this to Java so that it compiles?</p>
<p>There is no need to deal with <code>Optional</code> here.</p>
<p>The simplest straight-forward solution is to use <code>filter</code></p>
<pre><code>List&lt;String&gt; result = x.stream()
    .filter(val -&gt; !val.equals("b"))
    .collect(Collectors.toList());
</code></pre>
<p>If you insist on using <code>flatMap</code>, you should simply use <code>Stream</code> instead of <code>Optional</code>:</p>
<pre><code>List&lt;String&gt; result = x.stream().flatMap(
    val -&gt; val.equals("b")? Stream.empty(): Stream.of(val))
    .collect(Collectors.toList());
</code></pre>
<p>If you have to deal with an operation that unavoidably produces an <code>Optional</code>, you will have to convert it to a <code>Stream</code> for using <code>Stream.flatMap</code>:</p>
<pre><code>List&lt;String&gt; result = x.stream()
    .map(val -&gt; val.equals("b") ? Optional.&lt;String&gt;empty() : Optional.of(val))
    .flatMap(o-&gt;o.map(Stream::of).orElse(Stream.empty()))
    .collect(Collectors.toList());
</code></pre>
<p><code>flatMap</code> is expected to map an element of the input <code>Stream</code> into a different <code>Stream</code>. Therefore it must return a <code>Stream</code> and not an <code>Optional</code>. </p>
<p>Therefore, you should do something like this :</p>
<pre><code>List&lt;String&gt; x = Arrays.asList("a", "b", "c");
List&lt;Optional&lt;String&gt;&gt; result = 
    x.stream()
     .flatMap((val) -&gt; 
                  val.equals("b") ? Stream.of(Optional.empty()) : 
                                    Stream.of(Optional.of(val)))
     .collect(Collectors.toList());
</code></pre>
<p>Note that if your goal is simply to get rid of some of the values ("b" in your example), you don't need to use Optional at all. You can just filter the Stream :</p>
<pre><code>List&lt;String&gt; result = 
    x.stream()
     .filter (val -&gt; !val.equals("b"))
     .collect(Collectors.toList());
</code></pre>
<p>This way you don't need <code>flatMap</code> and your output is a <code>List&lt;String&gt;</code> instead of a <code>List&lt;Optional&lt;String&gt;&gt;</code>. </p>
<p>As Holger commented, the solution that returns a <code>Stream</code> of <code>Optional</code>s can be simplified by using <code>map</code> instead of <code>flatMap</code>, since each element is mapped into a single <code>Optional</code> :</p>
<pre><code>List&lt;String&gt; x = Arrays.asList("a", "b", "c");
List&lt;Optional&lt;String&gt;&gt; result = 
    x.stream()
     .map((val) -&gt; val.equals("b") ? Optional.empty() : Optional.of(val))
     .collect(Collectors.toList());
</code></pre>