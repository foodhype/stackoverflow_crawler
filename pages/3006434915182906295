<h1>
java - can I use static boolean variable as a lock for a synchronized thread? - Stack Overflow
<\h1>
<p>I tried to use static boolean variable to lock and unlock two synchronized threads.
So I wrote the following code:</p>
<pre><code>public class Main {

    public static void main(String[] args){

        //MyObject lock = new MyObject();
        Thread1 t1 = new Thread1(100,'#');
        Thread1 t2 = new Thread1(100,'*');

        t1.start();
        t2.start();
    }
}
</code></pre>
<hr/>
<pre><code>public class Thread1 extends Thread {

    public static boolean lock;
    int myNum;
    char myChar;

    public Thread1(int num, char c){
        myNum = num;
        myChar = c;
        lock = false;
    }

    public synchronized void run(){
        System.out.println(getName() + " is runing");
        while (Thread1.lock == true){
            System.out.println(getName() + " is waiting");
            try{wait();}
            catch(InterruptedException e){}
        }
        Thread1.lock = true;
        for(int i = 0; i&lt;myNum; i++){
            if(i%10==0)
                System.out.println("");
            System.out.print(myChar);
        }
        Thread1.lock = false;
        notifyAll();
    }
}
</code></pre>
<p>probably I am not doing it right, cause only one thread is printing the "mychar" and the other thread is just going into wait() and not waking up when I do the notifyAll().
I thought that this can be a good way to use a static boolean variable for the whole class and than change it every time and call notifyAll() to check this flag in the others objects...</p>
<p>output example:</p>
<pre><code>Thread-0 is runing

Thread-1 is runing
Thread-1 is waiting
##########
##########
##########
##########
##########
##########
##########
##########
##########
##########
</code></pre>
<p><strong>Why it doesn't work</strong></p>
<p><code>notify()</code> and <code>wait()</code> work with the "monitor" of the object they are called on.  In your case, that is the <code>this</code>, the particular instance of <code>Thread1</code> that is running.</p>
<p>So, when <code>Thread-0</code> runs:</p>
<ul>
<li>it checks <code>lock</code></li>
<li>finds it <code>false</code></li>
<li>it runs the main code</li>
<li>it calls <code>notifyAll()</code> on <code>this</code> (which is itself, <code>Thread-0</code>).</li>
</ul>
<p><code>Thread-1</code> runs:</p>
<ul>
<li>it checks <code>lock</code></li>
<li>finds that it is <code>true</code></li>
<li>and calls <code>wait()</code> on <code>this</code> (which is itself, <code>Thread-1</code>)</li>
</ul>
<p>Since <code>Thread-0</code> calls <code>notifyAll()</code> on <code>this</code> (which is itself), and <code>Thread-1</code> calls <code>wait()</code> on <code>this</code> (which is <em>itself</em>), <code>Thread-1</code> is waiting on a different monitor than <code>Thread-0</code> is notifying, so it is never released.</p>
<p><strong>Solution</strong></p>
<p>If your plan is to just get that code to run sequentially, use this:</p>
<pre><code>public class Thread1 extends Thread {

    private static final Object lock = new Object();

    public void run(){
        // non-sequential code
        System.out.println(getName() + " is running");
        synchronized (lock) {
            // this code will be run sequentially by one thread at a time
        }
        // non-sequential code
    }
}
</code></pre>
<p>Sorry, but this provides negative value, because it has no guarantees and only gives an illusion of safety. There are several issues with this:</p>
<ol>
<li>The variable is non-volatile, as such changes from one thread may not be visible to the other.</li>
<li>Your locking is not atomic. Hence what could happen is both threads can pass the while loop, and then both set the boolean to true.</li>
<li><code>notifyAll()</code> wakes up all threads waiting <em>on the object instance</em>. And since each thread is waiting on itself as the monitor, they are not getting woken up. </li>
</ol>
<p>There are plenty of good locking mechanisms in Java - try the ones in the concurrency package (Though in your case a simple synchronized block is enough). If you insist on using a boolean for a lock, you would need to:</p>
<ol>
<li>Make a static <em>final</em> <code>AtomicBoolean</code> as you signaler (non final is fine as long as you don't change it and guarantee visibility)</li>
<li>Use <code>compareAndSet</code> as your looping/locking condition so that access is atomic.</li>
<li><code>Wait()</code> on the <code>AtomicBoolean</code> so that the threads share the monitor they are waiting on (and <code>notifyAll()</code> on it as well).</li>
</ol>
<p>You can use a simpler way to synchronize the threads.</p>
<pre><code>class Thread1 extends Thread {

    private static final Object lock = new Object();
    int myNum;
    char myChar;

    public Thread1(int num, char c){
        myNum = num;
        myChar = c;
    }

    public void run(){
        System.out.println(getName() + " is runing");
        synchronized(lock) {
            for(int i = 0; i&lt;myNum; i++){
                if(i%10==0)
                    System.out.println("");
                System.out.print(myChar);
            }
        }
    }
}
</code></pre>