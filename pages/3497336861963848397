<h1>
java - why this synchronized method is not working as expected? - Stack Overflow
<\h1>
<p>Could someone explain two me why these to codes dont output the same results (the only difference between two codes is in the run() method) ?</p>
<p>NB: the first code seems not doing any lock!</p>
<p><strong>First Code:</strong></p>
<pre><code>class LetterThread extends Thread 
{

    private StringBuffer letter;

    public static void main(String[] args) {
        StringBuffer sbltr = new StringBuffer("A");

        LetterThread one = new LetterThread(sbltr);
        LetterThread two = new LetterThread(sbltr);
        LetterThread three = new LetterThread(sbltr);

        one.setName("Thread ONE");
        two.setName("Thread TWO");
        three.setName("Thread THREE");

        one.start();
        two.start();
        three.start();

    }

    LetterThread(StringBuffer letter) {
        this.letter = letter;
    }

    public synchronized void run() {
        {
            for (int x = 0; x &lt; 100; x++) {
                System.out.println(Thread.currentThread().getName() + " (" + x
                        + ") = " + letter);
            }

            letter.setCharAt(0, (char) (letter.charAt(0) + 1));
        }
    }
}
</code></pre>
<p><strong>Second Code:</strong> this code is working exactely as expecting to </p>
<pre><code>class LetterThread extends Thread 
{

    private StringBuffer letter;

    public static void main(String[] args) {
        StringBuffer sbltr = new StringBuffer("A");

        LetterThread one = new LetterThread(sbltr);
        LetterThread two = new LetterThread(sbltr);
        LetterThread three = new LetterThread(sbltr);

        one.setName("Thread ONE");
        two.setName("Thread TWO");
        three.setName("Thread THREE");

        one.start();
        two.start();
        three.start();

    }

    LetterThread(StringBuffer letter) {
        this.letter = letter;
    }

    public void run() {
        synchronized (letter) {
            for (int x = 0; x &lt; 100; x++) {
                System.out.println(Thread.currentThread().getName() + " (" + x
                        + ") = " + letter);
            }

            letter.setCharAt(0, (char) (letter.charAt(0) + 1));
        }
    }
</code></pre>
<p><strong>First Code</strong></p>
<p>The thing is that you have 3 instances of a thread and each threads runs it's own <code>synchronized</code> instance of the method <code>run()</code>. But there is always only one thread that is wating to be synchronized to it's own <code>run()</code> method, so it will run whenever the threads wants it to run. This results in no synchronization at all.</p>
<p><strong>Second Code</strong></p>
<p>You have also 3 instances of a thread, but they <em>share a reference</em> to the letter object. Therefore if you lock this reference, the threads will exclude each other and the code runs as expected.</p>
<p><strong>Additional Information</strong></p>
<p>This post explains pretty good why the first solution doesn't work: <a href="http://stackoverflow.com/questions/7313657/should-you-synchronize-the-run-method-why-or-why-not">Should you synchronize the run method? Why or why not?</a></p>