<h1>
java - IntelliJ IDEA suggests replacing for loops with foreach method. Should I always do that when possible? - Stack Overflow
<\h1>
<p>IDEA suggests to replace, for example, this:</p>
<pre><code>for (Point2D vertex : graph.vertexSet()) {
  union.addVertex(vertex);
}
</code></pre>
<p>with this:</p>
<pre><code>graph.vertexSet().forEach(union::addVertex);
</code></pre>
<p>This new version is sure much more readable. But are there situations when I'd better stick to the good old language construct for iteratables rather than using the new <code>foreach</code> method?</p>
<p>For instance, if I understand correctly, the method reference mechanism implies constructing an anonymous <code>Consumer</code> object that otherwise (with <code>for</code> language construct) would not be constructed. Could that become a performance bottleneck for some actions?</p>
<p>So I wrote this not very exhaustive benchmark:</p>
<pre><code>package org.sample;

import org.openjdk.jmh.annotations.Benchmark;
import org.openjdk.jmh.annotations.Fork;
import org.openjdk.jmh.annotations.Threads;
import org.openjdk.jmh.infra.Blackhole;
import org.tendiwa.geometry.Point2D;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class LanguageConstructVsForeach {
    private static final int NUMBER_OF_POINTS = 10000;
    private static final List&lt;Point2D&gt; points = IntStream
        .range(0, NUMBER_OF_POINTS)
        .mapToObj(i -&gt; new Point2D(i, i * 2))
        .collect(Collectors.toList());

    @Benchmark
    @Threads(1)
    @Fork(3)
    public void languageConstructToBlackhole(Blackhole bh) {
        for (Point2D point : points) {
            bh.consume(point);
        }
    }
    @Benchmark
    @Threads(1)
    @Fork(3)
    public void foreachToBlackhole(Blackhole bh) {
        points.forEach(bh::consume);
    }
    @Benchmark
    @Threads(1)
    @Fork(3)
    public List&lt;Point2D&gt; languageConstructToList(Blackhole bh) {
        List&lt;Point2D&gt; list = new ArrayList&lt;&gt;(NUMBER_OF_POINTS);
        for (Point2D point : points) {
            list.add(point);
        }
        return list;
    }
    @Benchmark
    @Threads(1)
    @Fork(3)
    public List&lt;Point2D&gt; foreachToList(Blackhole bh) {
        List&lt;Point2D&gt; list = new ArrayList&lt;&gt;(NUMBER_OF_POINTS);
        points.forEach(list::add);
        return list;
    }

}
</code></pre>
<p>And got: </p>
<pre><code>Benchmark                                                       Mode  Samples      Score     Error  Units
o.s.LanguageConstructVsForeach.foreachToBlackhole              thrpt       60  33693.834 ± 894.138  ops/s
o.s.LanguageConstructVsForeach.foreachToList                   thrpt       60   7753.941 ± 239.081  ops/s
o.s.LanguageConstructVsForeach.languageConstructToBlackhole    thrpt       60  16043.548 ± 644.432  ops/s
o.s.LanguageConstructVsForeach.languageConstructToList         thrpt       60   6499.527 ± 202.589  ops/s
</code></pre>
<p>How comes <code>foreach</code> is more efficient in both cases: when I do virtually nothing and when I do some actual work? Doesn't <code>foreach</code> simply encapsulate <code>Iterator</code>? Is this benchmark even correct? If it is, is there any reason today to use the old language construct with Java 8?</p>
<p>You're comparing the language's "enhanced-for" loop with the <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Iterable.html#forEach-java.util.function.Consumer-" rel="nofollow"><code>Iterable.forEach()</code></a> method. The benchmark isn't obviously wrong, and the results might seem surprising, until you dig into the implementations.</p>
<p>Note that the <code>points</code> list is an instance of <code>ArrayList</code> since that's what's created by the <code>Collectors.toList()</code> collector.</p>
<p>The enhanced-for loop on an <code>Iterable</code> gets an <code>Iterator</code> from it and then calls <code>hasNext()</code> and <code>next()</code> repeatedly until there are no more elements. (This differs from the enhanced-for loop over an array, which does arithmetic and direct array element access.) Thus, when looping over an <code>Iterable</code>, this loop will perform a minimum of two method calls per iteration.</p>
<p>By contrast, calling <code>ArrayList.forEach()</code> runs a conventional, int-based for-loop over the array containing the list elements, and calls the lambda once per iteration. There's only one call per iteration here, as opposed to two calls per iteration for the enhanced-for loop. That might explain why <code>ArrayList.forEach()</code> is faster in this case.</p>
<p>The blackhole case seems to do very little work other than run the loops, so these cases seem to be measuring pure loop overhead. That may be why <code>ArrayList.forEach()</code> shows such a big advantage here.</p>
<p>When the loop does just a little bit of work (adding to a destination list) there is still a speed advantage for <code>ArrayList.forEach()</code>, but it's a much smaller difference. I suspect that if you were to do more work inside the loop, the advantage would be even smaller. This shows that the loop overhead for either construct is very small. Try using <code>BlackHole.consumeCPU()</code> in the loop. I wouldn't be surprised if the results between the two constructs becomes indistinguishable.</p>
<p>Note that the big speed advantage occurs because <code>Iterable.forEach()</code> ends up having a specialized implementation in <code>ArrayList.forEach()</code>. If you were to run <code>forEach()</code> over a different data structure, you'd probably get different results.</p>
<p>I wouldn't use this as justification for blindly replacing all enhanced-for loops with calls to <code>Iterable.forEach()</code>. Write the code that's the clearest and that makes the most sense. If you are writing performance critical code, benchmark it! Different forms will have different performance, depending on the workload, what data structure is being traversed, etc.</p>