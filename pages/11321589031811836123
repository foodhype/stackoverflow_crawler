<h1>
java - Is it a good practice to create and use String objects for locking in thread synchronization? - Stack Overflow
<\h1>
<p><em>Sorry for my English</em></p>
<p>I don't use any of fields for the locking because so I shouldn't think about could or couldn't some field have value <code>null</code>.</p>
<p>I always create special fields used only for locking in thread synchronization.</p>
<p>For example:</p>
<pre><code>public class Worker {

    private static final List&lt;Toilet&gt; TOILETS = Arrays.asList(
        new Toilet(1),
        new Toilet(2),
        // ...
        new Toilet(NUMBER_OF_FLOORS)
    );

    // here it is:
    private static final List&lt;String&gt; LOCK_TOILETS = Arrays.asList(
        "LOCK TOILET #1",
        "LOCK TOILET #2",
        // ...
        "LOCK TOILET #" + NUMBER_OF_FLOORS
    );

    private final int floorNumber;

    public void spendWorkingHours() {
        for (int i = 0; i &lt; X; ++i) {
            doWork();
            snackSomething();
            String lockToilet = LOCK_TOILETS.get(floorNumber);
            Toilet theOnlyToiletOnTheFloor = TOILETS.get(floorNumber);
            synchronized (lockToilet) {
                goToToilet(theOnlyToiletOnTheFloor);
            }
        }

    }

}
</code></pre>
<p>You should not use <code>String</code>s for lock objects especially not <em>string literals</em>.</p>
<p>String literals are from the <code>String</code> pool and each <code>String</code> literal which is the same string is the <em>same</em> reference. This means if 2 different threads use 2 "different" string literals are actually the same and hence deadlock can easily occur.</p>
<p>To demonstrate:</p>
<pre><code>// Thread #1
String LOCK1 = "mylock";
synchronized (LOCK1) {
}

// Thread #2
String LOCK2 = "mylock";
synchronized (LOCK2) {
    // This is actually the SAME lock,
    // might cause deadlock between the 2 synchronized blocks!
    // Because LOCK1==LOCK2!
}
</code></pre>
<p>Best would be to synchronize on private objects which are not accessible from the "outside". If you use an <code>Object</code> for lock which is visible from "outside" (or returned by a method), that object is available to anyone to also use as a lock which you have no control over and may cause a deadlock with your internal <code>synchronized</code> block.<br/>
For example you can synchronize on the object you whish to guard if it is private, or create a private, internal lock <code>Object</code>:</p>
<pre><code>private final Object LOCK = new Object();

// Later:
synchronized (LOCK) {
    // LOCK is not known to any "outsiders", safe to use it as internal lock
}
</code></pre>
<p>Using a <code>String</code> may not be the best idea, because this class gets a bit of special treatment, and strings with the same contents may be reused (so locking a toilet on the first floor would also lock the toilet with the same number on the other floors).</p>
<p>Your best choice here is locking the actual toilet.</p>
<p>There is no need for <code>lockToilet</code> why don't you just use a <a href="http://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html" rel="nofollow">synchronized statement</a> over each <code>TOILET</code> resource?</p>
<pre><code>Toilet t;
syncrhonized(TOILETS)
{
     t = = TOILETS.get(floorNumber);
}

synchronized (t) {
            goToToilet(t);
 }
</code></pre>
<p><code>syncrhonized</code> In this code means that any use of the object between parentheses is thread exclussive within the scope between brakets thus this object becoming a lock.</p>
<p>Answers do cover your question regarding the use of Strings for locking (See String interning for more details) so I will just mention a few other considerations:</p>
<p>Although you have defined the <code>List</code> as <code>final</code> (Cannot assign another list instance) and initialized with <code>.asList(..)</code> (Cannot change size) this doesn't make read-only or <code>thread-safe</code>, so if someone changes elements in that list you might get into an unstable state. Consider using a read-only list.</p>
<p>You also need to clarify the scope of locking. What are you trying to lock against? If <code>goToToilet</code> changes the object attributes, then the point of synchronization would be better placed in the method that changes the state of the <code>Object</code>. (This is a design recommendation; The code would work but would also be prone to errors when changing the code in the future)</p>
<p>Finally, I would also have a look in java <code>concurrent</code> structures as you might find concurrent collections and locking mechanisms useful.</p>