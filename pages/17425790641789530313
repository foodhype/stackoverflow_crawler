<h1>
java - getResourceAsStream in dynamically loaded jar - Stack Overflow
<\h1>
<p>I kow there are dozens (if not hundreds) questions about Java's getResource/getResourceAsStream but i did not find any answers to my problem. </p>
<p>I load jars dynamically with: (<code>String path</code> is given)</p>
<pre><code>File jar = new File(path);
URL url = new URL("file", "localhost", jar.getAbsolutePath());
URLClassLoader loader = new URLClassLoader(new URL[] { url });
c = loader.loadClass(name);
</code></pre>
<p>Then within the jar i try to load a resource in the jar. This resource clearly exists in the jar and the whole procedure works if I just run the whole thing with a class loader in Eclipse. In a jar it does not work.$</p>
<pre><code>getClass().getResourceAsStream("resource.dat"); 
</code></pre>
<p>I tried every possible combination of <code>/packageName/resource.dat</code>, <code>packageName/resource.dat</code>, <code>/resource.dat</code> and <code>resource.dat</code>. They all throw a <code>stream closed</code> Exception.  </p>
<p>The I tried debugging and ended up printing the URL of these files loaded via <code>getClass().getResource(path)</code></p>
<p>This led to following URL and it does not look normal to me. Is it supposed to say "localhostC:..."?</p>
<pre><code>jar:file://localhostC:\Users\******\export.jar!/packageName/resource.dat
</code></pre>
<p>Converting this URL also throws an Exception (<code>URISyntaxException</code>).</p>
<p>Is this URL really broken or am I just doing something wrong?</p>
<p>Try changing the line:</p>
<pre><code>URL url = new URL("file", "localhost", jar.getAbsolutePath());
</code></pre>
<p>to </p>
<pre><code>URL url = new URL("file", null, jar.getAbsolutePath());
</code></pre>
<p>The host parameter in the URL constructor is not applicable in this case.</p>
<p>First, the <code>File</code> class has a <a href="http://docs.oracle.com/javase/8/docs/api/java/io/File.html#toURI--" rel="nofollow"><code>toURI()</code></a> method, so the preferred way to get a URL pointing to a file is:</p>
<pre><code>URL url = new File(path).toURI().toURL();
</code></pre>
<p>So using this, the class loader:</p>
<pre><code>File jar = new File(path);
URLClassLoader loader = new URLClassLoader(new URL[] { jar.toURI().toURL() });
</code></pre>
<p>Next, when you want to load a resource for the jar, use a <code>Class</code> that is originating from the jar, so if you already loaded the <code>Class c</code>:</p>
<pre><code>Class&lt;?&gt; c = loader.loadClass(classPathAndName);
URL resource = c.getResource("data.txt");
</code></pre>
<p>This will result in something like:</p>
<pre><code>jar:file:/C:/test/testjar.jar!/testpkg/data.txt
</code></pre>
<p>Alternatively you can use the <code>ClassLoader</code> to get the resource like:</p>
<pre><code>loader.getResoure(packageAndResourceName);
</code></pre>
<p>But note that this quoting from the <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html#getResource-java.lang.String-" rel="nofollow">javadoc</a>:</p>
<blockquote>
<p>This method will first search the parent class loader for the resource; if the parent is <code>null</code> the path of the class loader built-in to the virtual machine is searched. That failing, this method will invoke <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/ClassLoader.html#findResource-java.lang.String-" rel="nofollow"><code>findResource(String)</code></a> to find the resource.</p>
</blockquote>